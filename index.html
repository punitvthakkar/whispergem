<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Whispers in the Garden</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #f9f7f0; /* Default background */
            color: #333;
        }
        canvas {
            display: block;
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(249, 247, 240, 0.95); /* Light background for overlay */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
            z-index: 100;
        }
        .overlay h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
            color: #34495e;
        }
        .overlay p {
            font-size: 1.1em;
            line-height: 1.6;
            max-width: 600px;
            margin-bottom: 15px;
        }
        .overlay ul {
            list-style: none;
            padding: 0;
            margin-bottom: 20px;
        }
        .overlay ul li {
            margin-bottom: 10px;
        }
        .overlay button {
            padding: 15px 30px;
            font-size: 1.2em;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .overlay button:hover {
            background-color: #2980b9;
        }
        .chart-container {
            width: 80%;
            max-width: 600px;
            margin: 10px auto;
        }
        /* Hide p5 canvas when overlay is active initially */
        #defaultCanvas0 { display: none; }
    </style>
</head>
<body>
    <div id="instructionScreen" class="overlay">
        <h1>Welcome to Whispers in the Garden!</h1>
        <p>This is a minimalist interactive visualization illustrating the Theory of Constraints (I=RT).</p>
        <p><strong>Objective:</strong> Observe how "idea particles" flow from a Source to a Destination through three pathways, each with unique constraints. Try to optimize the flow by interacting with the paths and the flow rate slider!</p>
        
        <h2>Gameplay Controls:</h2>
        <div id="desktopControls" style="display: none;">
            <ul>
                <li><strong>Reshape Paths:</strong> Click and drag near a path's curve to alter its shape.</li>
                <li><strong>Adjust Flow Rate:</strong> Use the slider at the bottom of the screen to change how quickly particles are generated.</li>
                <li><strong>Boost Path Capacity:</strong> Click directly on a path segment (not the draggable part) to temporarily enhance its throughput.</li>
            </ul>
        </div>
        <div id="mobileControls" style="display: none;">
            <ul>
                <li><strong>Reshape Paths:</strong> Tap and drag near a path's curve to alter its shape.</li>
                <li><strong>Adjust Flow Rate:</strong> Use the slider at the bottom of the screen to change how quickly particles are generated.</li>
                <li><strong>Boost Path Capacity:</strong> Tap directly on a path segment (not the draggable part) to temporarily enhance its throughput.</li>
            </ul>
        </div>
        <p>The game will run for <strong>2 minutes</strong>. Your performance and interaction style will be analyzed.</p>
        <button id="startGameButton">Tend Garden</button>
    </div>

    <div id="endScreen" class="overlay" style="display: none;">
        <h1>Garden Cycle Complete!</h1>
        <p>Here's how your system performed:</p>
        <div id="finalMetrics">
            <p><strong>Average Flow Rate (R):</strong> <span id="finalFlowRate"></span> particles/sec</p>
            <p><strong>Average Inventory (I):</strong> <span id="finalInventory"></span> particles</p>
            <p><strong>Average Flow Time (T = I/R):</strong> <span id="finalFlowTime"></span> seconds</p>
            <p><strong>Total Particles Processed:</strong> <span id="totalProcessed"></span></p>
        </div>
        
        <div class="chart-container">
            <canvas id="flowRateChart"></canvas>
        </div>
        <div class="chart-container">
            <canvas id="inventoryChart"></canvas>
        </div>
        
        <h2>Your Gardener Profile:</h2>
        <p id="personalityProfile">Analyzing your gardening style...</p>
        
        <button id="playAgainButton">Tend Another Garden</button>
    </div>

    <script>
    // Game State
    let gameState = 'instructions'; // 'instructions', 'playing', 'gameOver'
    let p5Canvas;

    // Tech Stack Constants (from spec)
    const colors = {
      background: "#f9f7f0", // A very light cream, good base
      particles: { // Kept these vibrant for visibility
        blue: "#3498db",
        green: "#2ecc71",
        red: "#e74c3c",
        yellow: "#f1c40f"
      },
      paths: {
        base: "#8FBC8F", // DarkSeaGreen - more organic
        highlight: "#DAA520", // Goldenrod - for highlights or active elements
        boost: "#FFA07A" // LightSalmon - for boost effect
      },
      nodes: {
        source: "#5F9EA0", // CadetBlue
        destination: "#BA55D3" // MediumOrchid
      },
      text: "#2F4F4F" // DarkSlateGray - for text, good contrast on light bg
    };

    // Core Mechanics Variables
    let particles = [];
    let completedParticles = []; // Stores particles that have reached the destination
    let paths = [];
    let flowSlider;
    let particleColors;

    // Adaptive Layout Variables
    let isMobile;
    let nodeSize;
    let particleBaseSize;
    let pathBaseThickness;
    let sourcePos, destPos;
    let backgroundGraphics; // For pre-rendering background

    // Scoring and Analysis Variables
    let startTime;
    let gameDuration = 120 * 1000; // 2 minutes in milliseconds
    let flowRate = 0;
    let systemInventory = 0;
    let bottleneckPathId = 'N/A';
    let metricsHistory = {
        time: [],
        flowRate: [],
        inventory: [],
        bottleneck: []
    };
    let historyInterval = 1000; // Log history every 1 second
    let lastHistoryLogTime = 0;

    // Personality Analysis Variables
    let playerMetrics = {
        pathPreference: [0, 0, 0], 
        bottleneckResponsiveness: 0,
        experimentalIndex: 0,
        boostUsage: 0
    };
    let lastBottleneckId = null;
    let lastBottleneckInteractions = [0,0,0];

    // Interaction Variables
    let interactionTarget = null; 
    let draggingPath = null;

    // p5.js setup function
    function setup() {
        p5Canvas = createCanvas(windowWidth, windowHeight);
        p5Canvas.id('defaultCanvas0'); 
        
        particleColors = Object.values(colors.particles);
        
        // setupLayout will call drawBackgroundPattern once
        // Initialize paths only when game starts
        
        if (isMobile === undefined) { // Initial check if not already set by early resize
            isMobile = windowWidth < 768;
        }

        if (isMobile) {
            document.getElementById('mobileControls').style.display = 'block';
            document.getElementById('desktopControls').style.display = 'none';
        } else {
            document.getElementById('desktopControls').style.display = 'block';
            document.getElementById('mobileControls').style.display = 'none';
        }
        // Actual game init (paths, etc.) moved to initializeGame()
    }
    
    function initializeGame() {
        gameState = 'playing';
        document.getElementById('instructionScreen').style.display = 'none';
        document.getElementById('endScreen').style.display = 'none';
        const p5CanvasEl = document.getElementById('defaultCanvas0');
        if(p5CanvasEl) {
            p5CanvasEl.style.display = 'block';
        }

        setupLayout(); // Sets up sizes, positions, and draws background first time

        particles = [];
        completedParticles = [];
        
        // Adjusted control points for better curves and separation
        const cpOffsetY = isMobile ? 60 : 100; // Control point Y offset for top/bottom paths
        paths = [
            new Path(0, 'rate', sourcePos, createVector(width * 0.5, height * 0.5 - cpOffsetY), destPos),
            new Path(1, 'time', sourcePos, createVector(width * 0.5, height * 0.5), destPos), // Middle path, can be straighter
            new Path(2, 'inventory', sourcePos, createVector(width * 0.5, height * 0.5 + cpOffsetY), destPos)
        ];

        playerMetrics = { pathPreference: [0, 0, 0], bottleneckResponsiveness: 0, experimentalIndex: 0, boostUsage: 0 };
        lastBottleneckId = null;
        lastBottleneckInteractions = [0,0,0];

        metricsHistory = { time: [], flowRate: [], inventory: [], bottleneck: [] };
        lastHistoryLogTime = 0;
        
        startTime = millis();
        flowSlider.value = 0.35; // Start with a bit more flow
        loop(); 
    }

    function draw() {
        if (gameState === 'playing') {
            image(backgroundGraphics, 0, 0); // Draw pre-rendered background
            // background(colors.background + '60'); // Alternative: slight transparency for trails on dynamic background

            let desiredParticlesPerSecond = map(flowSlider.value, 0.1, 1, 1, 12); // Slightly reduced max for clarity
            let frameInterval = frameRate() > 0 ? frameRate() / desiredParticlesPerSecond : 60 / desiredParticlesPerSecond;

            if (frameCount % Math.max(1, int(frameInterval)) === 0) {
                particles.push(new Particle(random(particleColors), sourcePos, particleBaseSize));
                // console.log("Particle created. Total:", particles.length); // For debugging
            }
            
            drawGardenElements();

            for (let path of paths) {
                path.update(); // Update path internal state (like gate timing, width oscillation)
                path.display();
            }
            
            updateParticles(); // Update all particles (movement, constraints)
            
            for (let p of particles) {
                p.display(); // Draw all particles
            }
            
            drawNode(sourcePos.x, sourcePos.y, nodeSize, true); // Draw source node
            drawNode(destPos.x, destPos.y, nodeSize, false); // Draw destination node
            
            drawSlider(); // Draw UI slider
            
            updateScore(); // Calculate metrics
            drawMetrics(); // Display metrics
            
            trackPlayerBehavior(); // Track player interactions for personality profile

            if (millis() - startTime > gameDuration) {
                gameState = 'gameOver';
                prepareEndScreenData();
                noLoop(); 
            }

        } else if (gameState === 'instructions' || gameState === 'gameOver') {
            // Overlays handle display; p5 canvas can be hidden or show a static background
            // If backgroundGraphics exists, draw it so there's no flicker if overlays are briefly hidden
            if (backgroundGraphics) image(backgroundGraphics, 0, 0);
            else background(colors.background);
        }
    }
    
    function drawBackgroundPattern(pg) {
        pg.loadPixels();
        let detail = 0.008; // Slightly coarser noise for more visible pattern
        let variance = 35; // Increased variance for more contrast
        let baseR = 230, baseG = 238, baseB = 225; // Soft garden-like base

        for (let x = 0; x < pg.width; x++) {
            for (let y = 0; y < pg.height; y++) {
                let noiseVal = noise(x * detail, y * detail, millis()*0.00001) * variance; // Subtle animation in noise
                let r = constrain(baseR + noiseVal, 0, 255);
                let g = constrain(baseG + noiseVal * 0.8, 0, 255); // Vary color channels differently
                let b = constrain(baseB + noiseVal * 1.2, 0, 255);
                pg.set(x, y, color(r, g, b, 200)); // Slightly more opaque
            }
        }
        pg.updatePixels();
    }

    function setupLayout() {
        isMobile = windowWidth < 768; 
        
        nodeSize = isMobile ? windowWidth * 0.11 : windowWidth * 0.06;
        particleBaseSize = isMobile ? random(8,10) : random(10,15) ; 
        pathBaseThickness = isMobile ? 20 : 30;
        
        // More inset source/dest for better path curves
        sourcePos = createVector(width * 0.1, height * 0.5);
        destPos = createVector(width * 0.9, height * 0.5);
        
        flowSlider = {
            x: width / 2,
            y: height - (isMobile ? 45 : 35),
            w: width * (isMobile ? 0.75 : 0.55),
            h: isMobile ? 30 : 22,
            value: flowSlider ? flowSlider.value : 0.35, // Preserve value on resize if already set
            dragging: false
        };
        
        // Create or recreate offscreen buffer for background
        if (backgroundGraphics) backgroundGraphics.remove(); // Dispose of old one if it exists
        backgroundGraphics = createGraphics(width, height);
        drawBackgroundPattern(backgroundGraphics); // Draw it once

        // Re-initialize paths with new layout if game is running
        if (gameState === 'playing' && paths.length > 0) {
            const cpOffsetY = isMobile ? 60 : 100;
             paths = [
                new Path(0, paths[0].type, sourcePos, createVector(width * 0.5, height * 0.5 - cpOffsetY), destPos, paths[0].controlPointUser),
                new Path(1, paths[1].type, sourcePos, createVector(width * 0.5, height * 0.5), destPos, paths[1].controlPointUser),
                new Path(2, paths[2].type, sourcePos, createVector(width * 0.5, height * 0.5 + cpOffsetY), destPos, paths[2].controlPointUser)
            ];
        }
    }

    class Particle {
        constructor(pColor, startPos, baseSize) {
            this.position = startPos.copy();
            this.velocity = p5.Vector.random2D().mult(random(0.8,1.8));
            this.acceleration = createVector(0, 0);
            this.maxSpeed = isMobile ? 2.8 : 4.5;
            this.color = pColor;
            this.size = random(baseSize * 0.7, baseSize * 1.1); 
            this.pathPosition = 0; 
            this.currentPath = null;
            this.pathIndex = -1;
            this.shapeVariant = random(['circle', 'soft_square']); 
        }

        applyForce(force) { this.acceleration.add(force); }
        
        findPathAndTarget() {
            let closestDistSq = Infinity;
            let targetPath = null;
            let targetPointOnPath = null; // The actual point on the path curve
            let targetPathIndex = -1;

            for (let i = 0; i < paths.length; i++) {
                const path = paths[i];
                let proj = path.getClosestPoint(this.position); // Gets {point, t, distSq}
                
                // Prefer paths the particle is already on or very close to
                let thresholdMultiplier = (this.currentPath === path) ? 4 : 2.5;
                if (proj.distSq < closestDistSq && proj.distSq < sq(path.thickness * thresholdMultiplier)) {
                    closestDistSq = proj.distSq;
                    targetPath = path;
                    targetPathIndex = i;
                    
                    let lookAheadT = min(1, proj.t + 0.1); // Look further ahead for smoother following
                    targetPointOnPath = path.getPointOnPath(lookAheadT);
                }
            }
            
            if (targetPath) {
                this.currentPath = targetPath;
                this.pathIndex = targetPathIndex;
                return targetPointOnPath; // This is the steering target
            }
            // Fallback: if no path found, steer towards destination
            let generalDirection = p5.Vector.sub(destPos, this.position);
            generalDirection.normalize().mult(this.maxSpeed * 0.5); // Move slower if not on path
            return p5.Vector.add(this.position, generalDirection);
        }

        update() {
            let target = this.findPathAndTarget();
            if (target) {
                let desired = p5.Vector.sub(target, this.position);
                // desired.normalize(); // Normalizing can cause jerky movements if target is close
                // desired.mult(this.maxSpeed);
                // Instead, scale desired velocity by distance to target, up to maxSpeed
                let d = desired.mag();
                desired.normalize();
                if (d < 100) { // If close to target point on path, scale speed
                    desired.mult(map(d, 0, 100, 0, this.maxSpeed));
                } else {
                    desired.mult(this.maxSpeed);
                }

                let steer = p5.Vector.sub(desired, this.velocity);
                steer.limit(isMobile ? 0.35 : 0.55); 
                this.applyForce(steer);
            }

            if (this.currentPath) {
                this.pathPosition = this.currentPath.getClosestPoint(this.position).t;
                let pathSpeedFactor = 1.0;
                let blocked = false;

                switch(this.currentPath.type) {
                    case 'rate':
                        let currentWidth = this.currentPath.getCurrentDynamicWidth();
                        pathSpeedFactor = map(currentWidth, this.currentPath.baseThickness * 0.2, this.currentPath.baseThickness * 1.8, 0.25, 1.6, true);
                        break;
                    case 'time':
                        for (let gate of this.currentPath.gates) {
                            if (abs(this.pathPosition - gate.positionT) < 0.04 && !gate.isOpen) { 
                                blocked = true; break;
                            }
                        }
                        break;
                    case 'inventory':
                        let filter = this.currentPath.getFilterAt(this.pathPosition);
                        if (filter && this.color !== filter.color) {
                            blocked = true;
                        }
                        break;
                }
                
                if (blocked) { this.velocity.mult(0.05); } // More pronounced slow down
                else { this.velocity.mult(constrain(pathSpeedFactor, 0.1, 2.5)); }
            }
            
            this.velocity.add(this.acceleration);
            this.velocity.limit(this.maxSpeed);
            this.position.add(this.velocity);
            this.acceleration.mult(0); 

            if (p5.Vector.dist(this.position, destPos) < nodeSize / 2 + this.size) { // Generous destination collection
                this.completionTime = millis(); // For rate calculation if needed
                return true; 
            }
            if (this.position.x < -this.size*2 || this.position.x > width + this.size*2 ||
                this.position.y < -this.size*2 || this.position.y > height + this.size*2) {
                return true; 
            }
            return false;
        }

        display() {
            push();
            translate(this.position.x, this.position.y);
            noStroke();
            fill(this.color);
            if (this.shapeVariant === 'soft_square') {
                 rectMode(CENTER); rect(0,0, this.size, this.size, this.size * 0.25);
            } else { ellipse(0, 0, this.size, this.size); }
            pop();
        }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        if (p.update()) { 
            if (p5.Vector.dist(p.position, destPos) < nodeSize / 2 + p.size) { // Check if actual destination reach
                 completedParticles.push(p);
                 if (p.currentPath) p.currentPath.particlesPassedSinceLastCheck++;
            }
            particles.splice(i, 1);
        }
      }
    }

    class Path {
        constructor(id, type, startVec, controlVec, endVec, existingControlPointUser = null) {
            this.id = id;
            this.type = type; 
            this.startPoint = startVec;
            this.endPoint = endVec;
            this.controlPointUser = existingControlPointUser ? existingControlPointUser.copy() : controlVec.copy(); 
            this.controlPoint = this.controlPointUser.copy();

            this.thickness = pathBaseThickness;
            this.baseThickness = pathBaseThickness; 
            this.interactionCount = 0;
            this.particlesPassedSinceLastCheck = 0; // Used for throughput calculation
            this.lastBoostTime = -Infinity;
            this.boostDuration = 3500; 
            this.boostActive = false;

            if (this.type === 'rate') { this.periodicWidthFactor = 1.0; } 
            else if (this.type === 'time') {
                this.gates = [];
                for (let i = 0; i < 3; i++) { 
                    this.gates.push({ positionT: 0.25 + i * 0.25, isOpen: true, cycleOffset: i * PI / 2.5 });
                }
            } else if (this.type === 'inventory') {
                this.filters = []; let numFilters = 3;
                for (let i = 0; i < numFilters; i++) {
                    this.filters.push({ positionT: 0.25 + i * (0.5 / (numFilters-1||1) ), color: particleColors[i % particleColors.length] });
                }
            }
        }

        update() {
            this.controlPoint.lerp(this.controlPointUser, 0.15); // Slightly faster spring to control point
            let currentTime = millis();
            if (this.type === 'rate') { this.periodicWidthFactor = 0.7 + sin(currentTime * 0.0012 + this.id) * 0.3; } // Oscillates between 0.4 and 1.0
            else if (this.type === 'time') {
                for (let gate of this.gates) {
                    gate.isOpen = this.boostActive ? true : (sin(currentTime * 0.0025 + gate.cycleOffset + this.id * 0.5) > 0);
                }
            }
            if (this.boostActive && currentTime - this.lastBoostTime > this.boostDuration) { this.boostActive = false; }
        }
        
        getCurrentDynamicWidth() {
            let w = this.baseThickness * this.periodicWidthFactor;
            if (this.boostActive && this.type === 'rate') { w *= 1.6; }
            return w;
        }
        
        getPointOnPath(t) {
            let x_bz = pow(1-t,2)*this.startPoint.x + 2*(1-t)*t*this.controlPoint.x + pow(t,2)*this.endPoint.x;
            let y_bz = pow(1-t,2)*this.startPoint.y + 2*(1-t)*t*this.controlPoint.y + pow(t,2)*this.endPoint.y;
            return createVector(x_bz, y_bz);
        }
        
        getAngleAt(t) {
            t = constrain(t, 0.001, 0.999); 
            let p1 = this.getPointOnPath(t-0.001); let p2 = this.getPointOnPath(t + 0.001);
            return atan2(p2.y - p1.y, p2.x - p1.x);
        }

        getClosestPoint(p) {
            let closestDistSq = Infinity; let closestT = 0; let closestPt = null;
            const steps = 50; // Reduced steps for performance, path following has look-ahead
            for (let i = 0; i <= steps; i++) {
                let t = i / steps; let pt = this.getPointOnPath(t);
                let dSq = p5.Vector.distSq(p, pt);
                if (dSq < closestDistSq) { closestDistSq = dSq; closestT = t; closestPt = pt;}
            }
            return { point: closestPt, t: closestT, distSq: closestDistSq };
        }

        display() {
            noFill();
            let currentPathColor = this.boostActive ? colors.paths.boost : colors.paths.base;
            
            // Constraint visualization
            switch(this.type) {
                case 'rate':
                    let segments = 15; // Fewer segments for performance, relying on stroke cap for smoothness
                    for (let i = 0; i < segments; i++) {
                        let t1 = i / segments; let t2 = (i + 1) / segments;
                        let p1 = this.getPointOnPath(t1); let p2 = this.getPointOnPath(t2);
                        let segWidthFactor = 0.65 + sin(t1 * TWO_PI * 1.5 + millis()*0.0015 + this.id) * 0.35; // Width varies along path
                        let segWidth = this.baseThickness * this.periodicWidthFactor * segWidthFactor;
                        if (this.boostActive) segWidth *= 1.6;
                        stroke(currentPathColor);
                        strokeWeight(max(3, segWidth)); strokeCap(ROUND); // Use ROUND cap
                        line(p1.x, p1.y, p2.x, p2.y);
                    }
                    break;
                case 'time':
                    stroke(currentPathColor); strokeWeight(this.thickness); strokeCap(PROJECT);this.drawCurve();
                    for (let gate of this.gates) {
                        let p = this.getPointOnPath(gate.positionT); let angle = this.getAngleAt(gate.positionT);
                        push(); translate(p.x, p.y); rotate(angle + HALF_PI); rectMode(CENTER);
                        let gateW = this.thickness * 1.2; let gateH = this.thickness * 0.7;
                        if (gate.isOpen) { fill(colors.paths.highlight); rect(0, 0, gateW*0.6, gateH*1.2); } // Open: thinner, taller
                        else { fill(currentPathColor); rect(0, 0, gateW, gateH); } // Closed: wider
                        pop();
                    }
                    break;
                case 'inventory':
                    stroke(currentPathColor); strokeWeight(this.thickness); strokeCap(PROJECT);this.drawCurve();
                    for (let filter of this.filters) {
                        let p = this.getPointOnPath(filter.positionT);
                        push(); translate(p.x, p.y); noStroke();
                        fill(filter.color + (this.boostActive ? 'FF' : 'CC'));
                        ellipse(0, 0, this.thickness * (this.boostActive ? 1.6 : 1.3));
                        fill(this.boostActive ? colors.background : colors.text); textAlign(CENTER, CENTER); textSize(this.thickness * 0.55);
                        text(this.getColorInitial(filter.color), 0, 1);
                        pop();
                    }
                    break;
            }
        }
        
        drawCurve() { beginShape(); for (let i = 0; i <= 1; i += 0.03) { let p = this.getPointOnPath(i); vertex(p.x, p.y); } endShape(); }
        getColorInitial(hexColor) { return hexColor === colors.particles.blue ? 'B' : hexColor === colors.particles.green ? 'G' : hexColor === colors.particles.red ? 'R' : hexColor === colors.particles.yellow ? 'Y' : '?'; }
        getFilterAt(particlePathPosT) {
            if (this.type !== 'inventory' || this.boostActive) return null; // Boost makes inventory path non-selective
            for (let filter of this.filters) { if (abs(particlePathPosT - filter.positionT) < 0.05) return filter; }
            return null;
        }
        moveControlPoint(x, y) { this.controlPointUser.set(x, y); }
        boost() {
            if (millis() - this.lastBoostTime > this.boostDuration + 1500) { // Cooldown
                this.lastBoostTime = millis(); this.boostActive = true; playerMetrics.boostUsage++;
            }
        }
        isMouseOver(mx, my) { // Check for path interaction (dragging or boosting)
            const checkDist = this.thickness * 0.8 + (isMobile ? 25 : 15); // Increased hit area
            // Check near control point for dragging
            if (dist(mx, my, this.controlPointUser.x, this.controlPointUser.y) < checkDist * 1.5) {
                return { type: 'drag' };
            }
            // Check along the path for boosting
            for (let t = 0; t <= 1; t += 0.1) { // Check 10 segments
                let p = this.getPointOnPath(t);
                if (dist(mx, my, p.x, p.y) < checkDist) return { type: 'boost' };
            }
            return null;
        }
    }

    function drawGardenElements() { /* Placeholder for future enhancements */ }

    function drawNode(x, y, r, isSource) {
        push(); translate(x, y); let pulse = sin(millis() * 0.0025) * (r * 0.12);
        let baseC = isSource ? colors.nodes.source : colors.nodes.destination;
        noStroke(); fill(baseC + '66'); ellipse(0, 0, r + pulse, r + pulse);
        fill(baseC); ellipse(0, 0, r * 0.65, r * 0.65);
        // More subtle emitter/collector effects
        for(let i=0; i < 4; i++){
            let angle = (isSource ? millis()*0.0015 : -millis()*0.001) + i * HALF_PI;
            let rad = r * 0.3 + pulse * (isSource ? 0.6 : 0.4);
            fill(colors.background + 'AA'); ellipse(cos(angle)*rad, sin(angle)*rad, r*0.08);
        }
        pop();
    }
    
    function drawSlider() {
        push(); let s = flowSlider; rectMode(CENTER);
        fill(colors.paths.base + '90'); noStroke(); rect(s.x, s.y, s.w, s.h * 0.4, s.h * 0.2);
        let thumbX = map(s.value, 0.1, 1, s.x - s.w / 2, s.x + s.w / 2);
        fill(s.dragging ? colors.paths.highlight : colors.particles.blue); stroke(colors.background); strokeWeight(2);
        ellipse(thumbX, s.y, s.h * 1.1, s.h * 1.1);
        pop();
        fill(colors.text); noStroke(); textAlign(CENTER, CENTER); textSize(isMobile ? 12.5 : 14.5);
        text(`Flow: ${(s.value * 100).toFixed(0)}%`, s.x, s.y - s.h * 1.6);
    }

    function handleMousePressed(event) {
        if (gameState !== 'playing') return;
        let mx = mouseX; let my = mouseY;
        let s = flowSlider;
        if (my > s.y - s.h && my < s.y + s.h && mx > s.x - s.w/2 - s.h && mx < s.x + s.w/2 + s.h) {
            s.dragging = true; interactionTarget = { type: 'slider' };
            s.value = constrain(map(mx, s.x - s.w/2, s.x + s.w/2, 0.1, 1), 0.1, 1);
            return; 
        }
        for (let i = paths.length - 1; i >= 0; i--) {
            let interactionType = paths[i].isMouseOver(mx, my);
            if (interactionType) {
                paths[i].interactionCount++; playerMetrics.pathPreference[i]++;
                if (interactionType.type === 'drag') {
                    draggingPath = paths[i]; interactionTarget = { type: 'pathDrag', id: i };
                } else if (interactionType.type === 'boost') {
                    paths[i].boost(); interactionTarget = { type: 'pathBoost', id: i };
                }
                return;
            }
        }
        interactionTarget = null; draggingPath = null;
    }

    function handleMouseDragged() {
        if (gameState !== 'playing' || !interactionTarget) return;
        let mx = mouseX; let my = mouseY;
        if (interactionTarget.type === 'slider' && flowSlider.dragging) {
            flowSlider.value = constrain(map(mx, flowSlider.x - flowSlider.w/2, flowSlider.x + flowSlider.w/2, 0.1, 1), 0.1, 1);
        } else if (interactionTarget.type === 'pathDrag' && draggingPath) {
            draggingPath.moveControlPoint(mx, my);
        }
    }
    function handleMouseReleased() { if (flowSlider) flowSlider.dragging = false; draggingPath = null; interactionTarget = null; }
    
    function updateScore() {
        if (!startTime) return; 
        let elapsedTimeSeconds = (millis() - startTime) / 1000;
        if (elapsedTimeSeconds <= 0) elapsedTimeSeconds = 0.01; 

        systemInventory = particles.length;
        flowRate = completedParticles.length / elapsedTimeSeconds;

        let pathThroughputs = paths.map((path, idx) => {
            let throughput = path.particlesPassedSinceLastCheck / (historyInterval/1000); // particles per sec for this interval
            // path.particlesPassedSinceLastCheck = 0; // Reset for next interval - MOVED to history logging
            return { id: idx, throughput: throughput };
        });

        if (pathThroughputs.length > 0 && millis() - lastHistoryLogTime >= historyInterval ) { // only update bottleneckPathId when logging
            let minThroughputPath = pathThroughputs.reduce((a, b) => a.throughput < b.throughput ? a : b);
            bottleneckPathId = minThroughputPath.id + 1; 
        } else if (bottleneckPathId === 'N/A' && pathThroughputs.length > 0) {
             bottleneckPathId = (pathThroughputs.reduce((a, b) => a.throughput < b.throughput ? a : b).id) + 1;
        }


        if (millis() - lastHistoryLogTime >= historyInterval) {
            metricsHistory.time.push(elapsedTimeSeconds.toFixed(1));
            metricsHistory.flowRate.push(flowRate.toFixed(2)); // Overall flow rate
            metricsHistory.inventory.push(systemInventory);
            metricsHistory.bottleneck.push(bottleneckPathId);
            lastHistoryLogTime = millis();
            paths.forEach(p => p.particlesPassedSinceLastCheck = 0); // Reset counter after use
        }
    }

    function drawMetrics() {
        fill(colors.text); noStroke(); textAlign(LEFT, TOP); textSize(isMobile ? 12 : 15);
        let textX = 20; let textY = 20; let lineSpacing = isMobile ? 18 : 21;
        text(`Time Left: ${max(0, (gameDuration - (millis() - startTime)) / 1000).toFixed(0)}s`, textX, textY); textY += lineSpacing;
        text(`Flow Rate (R): ${flowRate.toFixed(1)} p/s`, textX, textY); textY += lineSpacing;
        text(`Inventory (I): ${systemInventory}`, textX, textY); textY += lineSpacing;
        let flowTime = (flowRate > 0.01) ? (systemInventory / flowRate).toFixed(1) : 'N/A';
        text(`Flow Time (T): ${flowTime} s`, textX, textY); textY += lineSpacing;
        text(`Bottleneck: Path ${bottleneckPathId}`, textX, textY);
    }

    function trackPlayerBehavior() { /* Same as before */ 
        if (frameCount % 60 === 0) { 
            if (lastBottleneckId !== null && bottleneckPathId !== 'N/A' && parseInt(bottleneckPathId)-1 !== lastBottleneckId) {
                let newBottleneckIdx = parseInt(bottleneckPathId)-1;
                if (paths[newBottleneckIdx] && paths[newBottleneckIdx].interactionCount > lastBottleneckInteractions[newBottleneckIdx]) {
                    playerMetrics.bottleneckResponsiveness++;
                }
            }
            if (bottleneckPathId !== 'N/A' && paths[parseInt(bottleneckPathId)-1]) {
                lastBottleneckId = parseInt(bottleneckPathId)-1;
                paths.forEach((path, idx) => lastBottleneckInteractions[idx] = path.interactionCount);
            }
            let prefs = playerMetrics.pathPreference; let meanPref = prefs.reduce((a, b) => a + b, 0) / prefs.length;
            if (meanPref > 0) {
                let variance = prefs.reduce((sum, val) => sum + Math.pow(val - meanPref, 2), 0) / prefs.length;
                playerMetrics.experimentalIndex = Math.sqrt(variance) / meanPref;
            } else { playerMetrics.experimentalIndex = 0; }
        }
    }
    function prepareEndScreenData() { /* Same as before, ensure IDs are correct */ 
        let totalElapsedTime = max(1, (millis() - startTime) / 1000);
        let avgFlowRate = completedParticles.length / totalElapsedTime;
        let avgInventory = metricsHistory.inventory.length > 0 ? metricsHistory.inventory.reduce((s,v)=>s+v,0)/metricsHistory.inventory.length : 0;
        let avgFlowTime = avgFlowRate > 0.01 ? avgInventory / avgFlowRate : 0;

        document.getElementById('finalFlowRate').textContent = avgFlowRate.toFixed(2);
        document.getElementById('finalInventory').textContent = avgInventory.toFixed(1);
        document.getElementById('finalFlowTime').textContent = avgFlowTime.toFixed(1);
        document.getElementById('totalProcessed').textContent = completedParticles.length;

        let profile = ""; const totalInteractions = playerMetrics.pathPreference.reduce((a,b) => a+b, 0) + playerMetrics.boostUsage;
        if(playerMetrics.boostUsage > paths.length * 1.5){ profile += "An **Energetic Cultivator**, you actively boosted path flows! ";}
        else if(playerMetrics.boostUsage < paths.length * 0.5 && totalInteractions > 3){ profile += "A **Steady Hand**, preferring structural changes over temporary boosts. ";}
        if(playerMetrics.experimentalIndex > 0.7 && totalInteractions > 3){ profile += "A **Curious Explorer**, you reshaped many pathways. ";}
        else if(playerMetrics.experimentalIndex < 0.4 && totalInteractions > 3){ profile += "A **Focused Sculptor**, likely perfecting specific routes. ";}
        else if(totalInteractions <=3 ){ profile += "A **Gentle Observer**, letting the garden find its rhythm. ";}
        if(playerMetrics.bottleneckResponsiveness > 1){ profile += "You're **Quick to Adapt**, addressing bottlenecks as they shift. ";}
        else if(totalInteractions > 3){ profile += "You maintain a **Strategic Eye**, focusing on overall system design. ";}
        if (profile === "") profile = "Your unique gardening style is noted!";
        document.getElementById('personalityProfile').innerHTML = profile;

        document.getElementById('endScreen').style.display = 'flex';
        const p5CanvasEl = document.getElementById('defaultCanvas0'); if(p5CanvasEl) p5CanvasEl.style.display = 'none';
        
        // Ensure old charts are destroyed before creating new ones
        ['flowRateChart', 'inventoryChart'].forEach(id => {
            let chartInstance = Chart.getChart(id); if (chartInstance) chartInstance.destroy();
        });

        new Chart(document.getElementById('flowRateChart').getContext('2d'), { type: 'line', data: { labels: metricsHistory.time, datasets: [{ label: 'Avg Flow Rate (p/s)', data: metricsHistory.flowRate, borderColor: colors.particles.blue, tension: 0.1, fill: false }] }, options: { responsive: true, maintainAspectRatio: true, scales: { y: { beginAtZero: true } } } });
        new Chart(document.getElementById('inventoryChart').getContext('2d'), { type: 'line', data: { labels: metricsHistory.time, datasets: [{ label: 'System Inventory', data: metricsHistory.inventory, borderColor: colors.particles.green, tension: 0.1, fill: false }] }, options: { responsive: true, maintainAspectRatio: true, scales: { y: { beginAtZero: true } } } });
    }

    function touchStarted() { if (gameState === 'playing') { handleMousePressed(); return false; } return true; }
    function touchMoved() { if (gameState === 'playing') { handleMouseDragged(); return false; } return true; }
    function touchEnded() { if (gameState === 'playing') { handleMouseReleased(); return false; } return true; }
    
    function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        setupLayout(); // This will redraw background and update positions
    }

    document.addEventListener('DOMContentLoaded', (event) => {
        const p5_canvas_el = document.getElementById('defaultCanvas0');
        if (p5_canvas_el) p5_canvas_el.style.display = 'none';
        
        document.getElementById('startGameButton').addEventListener('click', () => {
            if (!p5Canvas && typeof setup === 'function') { 
                console.error("p5.js setup may not have fully completed or canvas not ready."); 
                // Attempt to ensure setup has run. This is a bit of a failsafe.
                // If p5 is in instance mode, this won't work directly.
                // Assuming global mode for now.
                if (typeof setup === 'function' && !select('#defaultCanvas0')) {
                  // This is tricky, p5 setup is usually self-invoking.
                  // For now, rely on standard p5 load order.
                }
            }
            initializeGame();
        });
        document.getElementById('playAgainButton').addEventListener('click', () => { initializeGame(); });

        // p5 global functions mousePressed, mouseDragged, mouseReleased are automatically called.
        // For touch, we define touchStarted, touchMoved, touchEnded globally.
    });

    // Make sure p5 input functions correctly call our handlers if gameState is 'playing'
    // (p5 will call these global functions if they exist)
    const originalMousePressed = typeof mousePressed === 'function' ? mousePressed : null;
    mousePressed = function(event) {
        if (originalMousePressed && gameState !== 'playing') originalMousePressed(event); // Allow p5 default if not playing
        if (gameState === 'playing') handleMousePressed(event);
    };
    const originalMouseDragged = typeof mouseDragged === 'function' ? mouseDragged : null;
    mouseDragged = function(event) {
        if (originalMouseDragged && gameState !== 'playing') originalMouseDragged(event);
        if (gameState === 'playing') handleMouseDragged(event);
    };
    const originalMouseReleased = typeof mouseReleased === 'function' ? mouseReleased : null;
    mouseReleased = function(event) {
        if (originalMouseReleased && gameState !== 'playing') originalMouseReleased(event);
        if (gameState === 'playing') handleMouseReleased(event);
    };
    </script>
</body>
</html>
